# -*- coding: utf-8 -*-
"""Clean valeurs foncières 2022.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uTYwKRAIfnDPXapVrWsLFKtrkNJiJA1K
"""

# librairies
import pandas as pd
import datetime
import seaborn as sns
import plotly.express as px

# Tables à importer:
#departements-region.csv
#ligstes_codes_postaux.csv
#loyer_moyen_par_ville.csv

df_valeursfoncieres = pd.read_csv('ValeursFoncieres-2022.txt', sep = '|')

df_valeursfoncieres.info()

pd.set_option('display.max_columns', None)

df_valeursfoncieres[(df_valeursfoncieres['Commune'] == 'VITROLLES') & (df_valeursfoncieres['Date mutation'] == '06/05/2024')]

# Identifier les achats d'immeuble pour les supprimer par la suite, moins exclusif: uniquement sur date, valeur fonciere et code postal
df_valeursfoncieres['doublon_a_supprimer'] = df_valeursfoncieres.duplicated(subset = ['Date mutation', 'Valeur fonciere','Code postal'])
df_valeursfoncieres

# Sélection des colonnes à garder

df_reduced_columns = df_valeursfoncieres[['Date mutation', 'Nature mutation', 'Valeur fonciere', 'No voie', 'B/T/Q', 'Type de voie', 'Code voie', 'Voie', 'Code postal', 'Commune', 'Code departement', 'Code commune', 'Surface Carrez du 1er lot','Surface Carrez du 2eme lot', 'Surface Carrez du 3eme lot', 'Surface Carrez du 4eme lot', 'Surface Carrez du 5eme lot', 'Nombre de lots', 'Code type local', 'Type local', 'Surface reelle bati', 'Nombre pieces principales', 'Surface terrain', 'doublon_a_supprimer']]

# Garder uniquement les appartements
df_appartements = df_reduced_columns[df_reduced_columns['Type local'] == 'Appartement']

df_appartements

# Remplir les codes postaux vides par les villes

df_appartements.loc[df_appartements['Commune'] == 'VILLENEUVE-LOUBET', 'Code postal'] = df_appartements.loc[df_appartements['Commune'] == 'VILLENEUVE-LOUBET', 'Code postal'].fillna(6270)
df_appartements.loc[df_appartements['Commune'] == 'AJACCIO', 'Code postal'] = df_appartements.loc[df_appartements['Commune'] == 'AJACCIO', 'Code postal'].fillna(20090)
df_appartements.loc[df_appartements['Commune'] == 'BASTIA', 'Code postal'] = df_appartements.loc[df_appartements['Commune'] == 'BASTIA', 'Code postal'].fillna(20200)
df_appartements.loc[df_appartements['Commune'] == 'TOURS', 'Code postal'] = df_appartements.loc[df_appartements['Commune'] == 'TOURS', 'Code postal'].fillna(37000)
df_appartements.loc[df_appartements['Commune'] == 'PAU', 'Code postal'] = df_appartements.loc[df_appartements['Commune'] == 'PAU', 'Code postal'].fillna(64000)
df_appartements.loc[df_appartements['Commune'] == 'CURIENNE', 'Code postal'] = df_appartements.loc[df_appartements['Commune'] == 'CURIENNE', 'Code postal'].fillna(73190)
df_appartements.loc[df_appartements['Commune'] == 'SAINT-PANCRACE', 'Code postal'] = df_appartements.loc[df_appartements['Commune'] == 'SAINT-PANCRACE', 'Code postal'].fillna(73300)
df_appartements.loc[df_appartements['Commune'] == 'SAINT GERVAIS LES BAINS', 'Code postal'] = df_appartements.loc[df_appartements['Commune'] == 'SAINT GERVAIS LES BAINS', 'Code postal'].fillna(74170)
df_appartements.loc[df_appartements['Commune'] == 'FLAYOSC', 'Code postal'] = df_appartements.loc[df_appartements['Commune'] == 'FLAYOSC', 'Code postal'].fillna(83780)
df_appartements.loc[df_appartements['Commune'] == 'ISSY-LES-MOULINEAUX', 'Code postal'] = df_appartements.loc[df_appartements['Commune'] == 'ISSY-LES-MOULINEAUX', 'Code postal'].fillna(92040)
df_appartements.loc[df_appartements['Commune'] == 'PARIS 16', 'Code postal'] = df_appartements.loc[df_appartements['Commune'] == 'PARIS 16', 'Code postal'].fillna(75016)
df_appartements.loc[df_appartements['Commune'] == 'AURIOL', 'Code postal'] = df_appartements.loc[df_appartements['Commune'] == 'AURIOL', 'Code postal'].fillna(13007)
df_appartements.loc[df_appartements['Commune'] == 'SAINT UZE', 'Code postal'] = df_appartements.loc[df_appartements['Commune'] == 'SAINT UZE', 'Code postal'].fillna(26240)
df_appartements.loc[df_appartements['Commune'] == 'LE BRIGNON', 'Code postal'] = df_appartements.loc[df_appartements['Commune'] == 'LE BRIGNON', 'Code postal'].fillna(43370)
df_appartements.loc[df_appartements['Commune'] == "BAGNOLES DE L'ORNE NORMANDIE", 'Code postal'] = df_appartements.loc[df_appartements['Commune'] == "BAGNOLES DE L'ORNE NORMANDIE", 'Code postal'].fillna(61140)
df_appartements.loc[df_appartements['Commune'] == 'ANNECY', 'Code postal'] = df_appartements.loc[df_appartements['Commune'] == 'ANNECY', 'Code postal'].fillna(74000)
df_appartements.loc[df_appartements['Commune'] == 'EPAGNY METZ-TESSY', 'Code postal'] = df_appartements.loc[df_appartements['Commune'] == 'EPAGNY METZ-TESSY', 'Code postal'].fillna(74330)
df_appartements.loc[df_appartements['Commune'] == 'CLAVIERS', 'Code postal'] = df_appartements.loc[df_appartements['Commune'] == 'CLAVIERS', 'Code postal'].fillna(83830)

# Vérifier qu'il n'y a aucun vide
df_bis = df_appartements[df_appartements['Code postal'].isnull()]
df_bis

# Fonction pour gérer la conversion des départements
def clean_departement(code):
    try:
        # Convertir en entier si possible, puis en string
        return str(int(float(code))).zfill(2)
    except ValueError:
        # Retourner le code d'origine s'il est déjà une chaîne valide (ex: '2A', '2B')
        return code

# Appliquer la fonction sur la colonne 'Code departement'
df_appartements['Code departement'] = df_appartements['Code departement'].apply(clean_departement)

# Convertir codes postaux en string
df_appartements['Code postal'] = df_appartements['Code postal'].astype(float).astype(int).astype(str)
df_appartements['Code postal'] = df_appartements['Code postal'].apply(lambda x: '0' + x if len(x) == 4 else x)

df_appartements.isnull().sum()

df_filtered = df_valeursfoncieres[
    ['No voie', 'Type de voie', 'Code voie', 'Voie', 'Code postal', 'Commune', 'Date mutation', '1er lot', 'Surface Carrez du 1er lot', '2eme lot',
     'Surface Carrez du 2eme lot', 'Nombre de lots', 'Type local',
     'Nombre pieces principales', 'Nature culture', 'Surface terrain', 'doublon_a_supprimer']
].dropna(subset=['Surface Carrez du 1er lot'])
df_filtered

# Vérifier le nombre de valeurs nulles
df_appartements.isnull().sum().sort_values(ascending= False)

# Créer nouvelle colonne pour compter le nombre de surfaces de lot vides pour consolidation
df_appartements['null_count'] = df_appartements[['Surface Carrez du 5eme lot',
                        'Surface Carrez du 4eme lot',
                        'Surface Carrez du 3eme lot',
                        'Surface Carrez du 2eme lot',
                        'Surface Carrez du 1er lot']].isna().sum(axis=1)

df_appartements.info()

# Convertir en date
df_appartements['Date mutation'] = pd.to_datetime(df_appartements['Date mutation'], format='%d/%m/%Y')

# Convertir en nombre
df_appartements['Valeur fonciere'] = df_appartements['Valeur fonciere'].str.replace(',','.').astype(float)

# Convertir en nombre
df_appartements['Surface Carrez du 1er lot'] = df_appartements['Surface Carrez du 1er lot'].str.replace(',','.').astype(float)

# Convertir en nombre
df_appartements['Surface Carrez du 2eme lot'] = df_appartements['Surface Carrez du 2eme lot'].str.replace(',','.').astype(float)

# Convertir en nombre
df_appartements['Surface Carrez du 3eme lot'] = df_appartements['Surface Carrez du 3eme lot'].str.replace(',','.').astype(float)

# Convertir en nombre
df_appartements['Surface Carrez du 4eme lot'] = df_appartements['Surface Carrez du 4eme lot'].str.replace(',','.').astype(float)

# Convertir en nombre
df_appartements['Surface Carrez du 5eme lot'] = df_appartements['Surface Carrez du 5eme lot'].str.replace(',','.').astype(float)

#df_appartements.info()

# Consolider la surface en 1 seule colonne sur la surface bâtie par défaut
df_appartements['surface_unique'] = df_appartements['Surface reelle bati']

# Convertir en nombre la colonne surface unique
df_appartements['surface_unique'] = df_appartements['surface_unique'].astype(float)

# Consolider la surface en 1 seule colonne si 4 nulles
df_appartements.loc[
    (df_appartements['null_count'] == 4) & (df_appartements['surface_unique'].isna()),
    'surface_unique'
] = df_appartements[
    ['Surface Carrez du 5eme lot',
     'Surface Carrez du 4eme lot',
     'Surface Carrez du 3eme lot',
     'Surface Carrez du 2eme lot',
     'Surface Carrez du 1er lot']
].bfill(axis=1).iloc[:, 0]

# Convertir en nombre la colonne surface unique
df_appartements['surface_unique'] = df_appartements['surface_unique'].astype(float)

# Consolider la surface en 1 seule colonne si 3 nulles
df_appartements.loc[
    (df_appartements['null_count'] < 4) & (df_appartements['surface_unique'].isna()),
    'surface_unique'
] = df_appartements[
    ['Surface Carrez du 5eme lot',
     'Surface Carrez du 4eme lot',
     'Surface Carrez du 3eme lot',
     'Surface Carrez du 2eme lot',
     'Surface Carrez du 1er lot']
].max(axis=1)

df_bis = df_appartements[df_appartements['surface_unique'].isnull()]
df_bis[['Surface Carrez du 1er lot', 'Surface Carrez du 2eme lot', 'Surface Carrez du 3eme lot', 'Surface Carrez du 4eme lot', 'Surface Carrez du 5eme lot', 'Surface reelle bati', 'Surface terrain', 'null_count', 'surface_unique']]

# Vérifier le nombre de valeurs nulles
df_appartements.isnull().sum().sort_values(ascending = False)

# Compilation des colonnes nécessaires + suppression des valeurs vides sur valeur foncière et surface

df_appartements_cleaned = df_appartements[['Date mutation'
                          ,'Nature mutation'
                          ,'Valeur fonciere'
                          ,'No voie'
                          ,'B/T/Q'
                          ,'Type de voie'
                          ,'Code voie'
                          ,'Voie'
                          ,'Code postal'
                          ,'Commune'
                          ,'Code departement'
                          ,'Code commune'
                          ,'Code type local'
                          ,'Type local'
                          ,'Nombre pieces principales'
                          ,'surface_unique'
                          ,'doublon_a_supprimer']].dropna(subset=['Valeur fonciere', 'surface_unique'])

# KPIS à ajouter
df_appartements_cleaned['Valeur fonciere par m2'] = df_appartements_cleaned['Valeur fonciere']/df_appartements_cleaned['surface_unique']
# prix au m2, faire un groupe par surface.

df_appartements_cleaned

# Enlever valeurs aberrantes:
# Enlever les surfaces de moins de 9m2
df_appartements_cleaned = df_appartements_cleaned[df_appartements_cleaned['surface_unique'] >=9]
df_appartements_cleaned.sort_values(by = 'surface_unique', ascending= False)

# Vérifier si distribution normale sur valeur foncière
fig = px.histogram(df_appartements_cleaned, x='Valeur fonciere', nbins=50, marginal="box", title="Distribution de valeur foncière")
fig.show()

fig = px.box(df_appartements_cleaned['Valeur fonciere'])
fig.show()

# Vérifier si distribution normale sur surface_unique
fig = px.histogram(df_appartements_cleaned, x='surface_unique', nbins=50, marginal="box", title="Distribution de surface_unique")
fig.show()

# Vérifier si distribution normale sur valeur foncière au m2
fig = px.histogram(df_appartements_cleaned, x='Valeur fonciere par m2', nbins=50, marginal="box", title="Distribution de surface_unique")
fig.show()

# Identifier les biens immobilier d'exception
df_appartements_cleaned['bien_exception'] = df_appartements_cleaned['Valeur fonciere'].apply(lambda x: 1 if x >= 2000000 else 0)

df_appartements_cleaned.sort_values(by = 'bien_exception', ascending= False)

## Supprimer les doublons identifiés
df_appartements_cleaned = df_appartements_cleaned[df_appartements_cleaned['doublon_a_supprimer'] == False]
df_appartements_cleaned.info()

df_appartements_cleaned = df_appartements_cleaned.rename(columns={'B/T/Q': 'BTQ'})

df_appartements_cleaned.isnull().sum()

"""# **Jointure avec les bons codes postaux**"""

# Importer la table codes postaux
df_insee = pd.read_csv('20230823-communes-departement-region.csv')

df_insee

# Convertir codes postaux en string
df_insee['code_postal'] = df_insee['code_postal'].astype(int).astype(str)
df_insee['code_postal'] = df_insee['code_postal'].apply(lambda x: '0' + x if len(x) == 4 else x)
df_insee

### to do: reprendre le même travail sur les départements

# Convertir codes INSEE en string

# Remplacer 'A' et 'B' par '0' dans les codes INSEE
df_insee['code_commune_INSEE'] = df_insee['code_commune_INSEE'].astype(str).str.replace(r'[AB]', '0', regex=True)

# Convertir en int puis en str pour enlever d'éventuelles parties décimales
df_insee['code_commune_INSEE'] = df_insee['code_commune_INSEE'].astype(int).astype(str)

# Ajouter un zéro devant les codes à 4 chiffres
df_insee['code_commune_INSEE'] = df_insee['code_commune_INSEE'].apply(lambda x: '0' + x if len(x) == 4 else x)
df_insee

## Jointure avec la table vente immo

df_jointure = df_appartements_cleaned.merge(df_insee, left_on="Code postal", right_on="code_postal", how="left")
df_jointure

df_jointure.isnull().sum().sort_values(ascending = False)

"""**Jointure avec la table loyer moyen**"""

# importer loyer moyen
df_loyer_moyen = pd.read_csv('loyer_moyen_par_ville.csv')

df_loyer_moyen

# Convertir codes postaux en string

# Remplacer 'A' et 'B' par '0' dans les codes INSEE
df_loyer_moyen['INSEE_code_postal'] = df_loyer_moyen['INSEE_code_postal'].astype(str).str.replace(r'[AB]', '0', regex=True)

# Convertir en int puis en str pour enlever d'éventuelles parties décimales
df_loyer_moyen['INSEE_code_postal'] = df_loyer_moyen['INSEE_code_postal'].astype(int).astype(str)

# Ajouter un zéro devant les codes à 4 chiffres
df_loyer_moyen['INSEE_code_postal'] = df_loyer_moyen['INSEE_code_postal'].apply(lambda x: '0' + x if len(x) == 4 else x)

df_loyer_moyen

df_loyer_moyen.info()

## Joindre avec la première table de jointure

df_complete = df_jointure.merge(df_loyer_moyen, left_on="code_commune_INSEE", right_on="INSEE_code_postal", how="left")

df_complete.isnull().sum().sort_values(ascending = False)

df_complete[df_complete['Fiabilité'].isnull()]

## Supprimer les valeurs nulles
df_complete = df_complete.dropna(subset = ["Fiabilité", "Nombre pieces principales", "latitude"])
df_complete.isnull().sum().sort_values(ascending = False)

df_appartements_cleaned = df_complete[[
"Date mutation",
"Valeur fonciere",
"No voie",
"BTQ",
"Type de voie",
"Code voie",
"Voie",
"code_postal",
"Commune_x",
"Code departement",
"Code commune",
"Type local",
"Nombre pieces principales",
"surface_unique",
"doublon_a_supprimer",
"Valeur fonciere par m2",
"bien_exception",
"code_commune_INSEE",
"Departement",
"Region",
"nom_departement",
"nom_region",
"loyer_moyen_par_m2",
"loyer_borne_basse_par_m2",
"loyer_borne_haute_par_m2",
"Fiabilité"]]
df_appartements_cleaned = df_appartements_cleaned.rename(columns = {"Commune_x" : "Commune"})
df_appartements_cleaned

# Convertir codes postaux en string

# Remplacer 'A' et 'B' par '0' dans les codes INSEE
df_appartements_cleaned['code_postal'] = df_appartements_cleaned['code_postal'].astype(str).str.replace(r'[AB]', '0', regex=True)

# Convertir en int puis en str pour enlever d'éventuelles parties décimales
df_appartements_cleaned['code_postal'] = df_appartements_cleaned['code_postal'].astype(int).astype(str)

# Ajouter un zéro devant les codes à 4 chiffres
df_appartements_cleaned['code_postal'] = df_appartements_cleaned['code_postal'].apply(lambda x: '0' + x if len(x) == 4 else x)

# Convertir codes postaux en string

# Remplacer 'A' et 'B' par '0' dans les codes INSEE
df_appartements_cleaned['code_postal'] = df_appartements_cleaned['code_postal'].astype(str).str.replace(r'[AB]', '0', regex=True)

# Convertir en int puis en str pour enlever d'éventuelles parties décimales
df_appartements_cleaned['code_postal'] = df_appartements_cleaned['code_postal'].astype(int).astype(str)

# Ajouter un zéro devant les codes à 4 chiffres
df_appartements_cleaned['code_postal'] = df_appartements_cleaned['code_postal'].apply(lambda x: '0' + x if len(x) == 4 else x)

df_appartements_cleaned.isnull().sum()

df_appartements_cleaned = df_appartements_cleaned.sort_values(
    by=["Code departement"],
    key=lambda x: x != "2A")
df_appartements_cleaned

df_appartements_cleaned.info()

df_appartements_cleaned.to_csv('prix_vente_appartement_cleaned_2022.csv')

# Vérifier si les surfaces fonctionnent bien avec les appartements
# to: ajouter les autres tables.
# to do: table de correspondance codes postaux
# to do: template dashbord looker
# à creuser: